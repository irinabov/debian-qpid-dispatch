Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 qpid-dispatch (1.2.0-1qpid+bionic1) bionic; urgency=medium
 .
   * Rebased to Dispatch 1.2.1
Author: Irina Boverman <iboverma@redhat.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2018-08-13

--- qpid-dispatch-1.2.0.orig/CMakeLists.txt
+++ qpid-dispatch-1.2.0/CMakeLists.txt
@@ -45,6 +45,13 @@ include(CheckIncludeFiles)
 include(FindPythonInterp)
 include(FindPythonLibs)
 
+
+if (PYTHON_VERSION_MAJOR STREQUAL 2)
+    set(PY_STRING "python")
+elseif(PYTHON_VERSION_MAJOR STREQUAL 3)
+    set(PY_STRING "python3")
+endif()
+
 # Find python-unittest2
 execute_process(COMMAND "${PYTHON_EXECUTABLE}" "-c" "import unittest2"
 			RESULT_VARIABLE UNITTEST2_MISSING
@@ -212,13 +219,16 @@ install(FILES include/qpid/dispatch.h DE
 install(FILES etc/qdrouterd.conf DESTINATION ${SYSCONF_INSTALL_DIR}/qpid-dispatch)
 install(FILES etc/sasl2/qdrouterd.conf DESTINATION ${SYSCONF_INSTALL_DIR}/sasl2)
 
+configure_file(${CMAKE_CURRENT_SOURCE_DIR}/tools/qdstat.in ${CMAKE_CURRENT_SOURCE_DIR}/tools/qdstat)
+configure_file(${CMAKE_CURRENT_SOURCE_DIR}/tools/qdmanage.in ${CMAKE_CURRENT_SOURCE_DIR}/tools/qdmanage)
+
+
 # Tools
 install(PROGRAMS
     ${CMAKE_CURRENT_SOURCE_DIR}/tools/qdstat
     ${CMAKE_CURRENT_SOURCE_DIR}/tools/qdmanage
     DESTINATION bin)
 
-
 # Doc files
 install(FILES
   LICENSE
@@ -230,6 +240,7 @@ add_subdirectory(src) # Build src first
 # run.py environment runner script - needs QPID_DISPATCH_LIB
 configure_file(${CMAKE_CURRENT_SOURCE_DIR}/run.py.in ${CMAKE_CURRENT_BINARY_DIR}/run.py)
 configure_file(${CMAKE_CURRENT_SOURCE_DIR}/run.py.in ${CMAKE_CURRENT_BINARY_DIR}/tests/run.py)
+configure_file(${CMAKE_CURRENT_SOURCE_DIR}/tests/authservice.py.in ${CMAKE_CURRENT_SOURCE_DIR}/tests/authservice.py)
 execute_process(COMMAND ${RUN} --sh OUTPUT_FILE config.sh)
 
 if (NOT UNITTEST2_MISSING)
--- /dev/null
+++ qpid-dispatch-1.2.0/patches/0001-DISPATCH-1087-Modified-shebang-line-in-some-files-to.patch
@@ -0,0 +1,159 @@
+From 30ff7ff1d54b8f280b36f76dc8c340cb4c88567b Mon Sep 17 00:00:00 2001
+From: Ganesh Murthy <gmurthy@redhat.com>
+Date: Wed, 25 Jul 2018 11:38:40 -0400
+Subject: [PATCH] DISPATCH-1087 - Modified shebang line in some files to put in
+ the correct version of Python
+
+---
+ CMakeLists.txt                              | 13 ++++++++++-
+ python/setup.py.in                          |  2 +-
+ run.py.in                                   | 36 ++++++++++++++---------------
+ tests/{authservice.py => authservice.py.in} |  2 +-
+ tools/{qdmanage => qdmanage.in}             |  2 +-
+ tools/{qdstat => qdstat.in}                 |  2 +-
+ 6 files changed, 34 insertions(+), 23 deletions(-)
+ rename tests/{authservice.py => authservice.py.in} (99%)
+ rename tools/{qdmanage => qdmanage.in} (99%)
+ rename tools/{qdstat => qdstat.in} (99%)
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index af2e004..28b3609 100644
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -45,6 +45,13 @@ include(CheckIncludeFiles)
+ include(FindPythonInterp)
+ include(FindPythonLibs)
+ 
++
++if (PYTHON_VERSION_MAJOR STREQUAL 2)
++    set(PY_STRING "python")
++elseif(PYTHON_VERSION_MAJOR STREQUAL 3)
++    set(PY_STRING "python3")
++endif()
++
+ # Find python-unittest2
+ execute_process(COMMAND "${PYTHON_EXECUTABLE}" "-c" "import unittest2"
+ 			RESULT_VARIABLE UNITTEST2_MISSING
+@@ -212,13 +219,16 @@ install(FILES include/qpid/dispatch.h DESTINATION ${INCLUDE_INSTALL_DIR}/qpid)
+ install(FILES etc/qdrouterd.conf DESTINATION ${SYSCONF_INSTALL_DIR}/qpid-dispatch)
+ install(FILES etc/sasl2/qdrouterd.conf DESTINATION ${SYSCONF_INSTALL_DIR}/sasl2)
+ 
++configure_file(${CMAKE_CURRENT_SOURCE_DIR}/tools/qdstat.in ${CMAKE_CURRENT_SOURCE_DIR}/tools/qdstat)
++configure_file(${CMAKE_CURRENT_SOURCE_DIR}/tools/qdmanage.in ${CMAKE_CURRENT_SOURCE_DIR}/tools/qdmanage)
++
++
+ # Tools
+ install(PROGRAMS
+     ${CMAKE_CURRENT_SOURCE_DIR}/tools/qdstat
+     ${CMAKE_CURRENT_SOURCE_DIR}/tools/qdmanage
+     DESTINATION bin)
+ 
+-
+ # Doc files
+ install(FILES
+   LICENSE
+@@ -230,6 +240,7 @@ add_subdirectory(src) # Build src first so other subdirs can use QPID_DISPATCH_L
+ # run.py environment runner script - needs QPID_DISPATCH_LIB
+ configure_file(${CMAKE_CURRENT_SOURCE_DIR}/run.py.in ${CMAKE_CURRENT_BINARY_DIR}/run.py)
+ configure_file(${CMAKE_CURRENT_SOURCE_DIR}/run.py.in ${CMAKE_CURRENT_BINARY_DIR}/tests/run.py)
++configure_file(${CMAKE_CURRENT_SOURCE_DIR}/tests/authservice.py.in ${CMAKE_CURRENT_SOURCE_DIR}/tests/authservice.py)
+ execute_process(COMMAND ${RUN} --sh OUTPUT_FILE config.sh)
+ 
+ if (NOT UNITTEST2_MISSING)
+diff --git a/python/setup.py.in b/python/setup.py.in
+index 10a1be6..25e4ede 100755
+--- a/python/setup.py.in
++++ b/python/setup.py.in
+@@ -1,4 +1,4 @@
+-#!/usr/bin/env python
++#!/usr/bin/env ${PY_STRING}
+ #
+ # Licensed to the Apache Software Foundation (ASF) under one
+ # or more contributor license agreements.  See the NOTICE file
+diff --git a/run.py.in b/run.py.in
+index 3233e3d..140f8b8 100755
+--- a/run.py.in
++++ b/run.py.in
+@@ -1,22 +1,22 @@
+-#!/usr/bin/env python
+-##
+-## Licensed to the Apache Software Foundation (ASF) under one
+-## or more contributor license agreements.  See the NOTICE file
+-## distributed with this work for additional information
+-## regarding copyright ownership.  The ASF licenses this file
+-## to you under the Apache License, Version 2.0 (the
+-## "License"); you may not use this file except in compliance
+-## with the License.  You may obtain a copy of the License at
+-##
+-##   http://www.apache.org/licenses/LICENSE-2.0
+-##
+-## Unless required by applicable law or agreed to in writing,
+-## software distributed under the License is distributed on an
+-## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+-## KIND, either express or implied.  See the License for the
+-## specific language governing permissions and limitations
+-## under the License
++#!/usr/bin/env ${PY_STRING}
+ ##
++# Licensed to the Apache Software Foundation (ASF) under one
++# or more contributor license agreements.  See the NOTICE file
++# distributed with this work for additional information
++# regarding copyright ownership.  The ASF licenses this file
++# to you under the Apache License, Version 2.0 (the
++# "License"); you may not use this file except in compliance
++# with the License.  You may obtain a copy of the License at
++#
++#   http://www.apache.org/licenses/LICENSE-2.0
++#
++# Unless required by applicable law or agreed to in writing,
++# software distributed under the License is distributed on an
++# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
++# KIND, either express or implied.  See the License for the
++# specific language governing permissions and limitations
++# under the License
++#
+ 
+ from __future__ import unicode_literals
+ from __future__ import division
+diff --git a/tests/authservice.py b/tests/authservice.py.in
+similarity index 99%
+rename from tests/authservice.py
+rename to tests/authservice.py.in
+index 7693b42..83c2786 100755
+--- a/tests/authservice.py
++++ b/tests/authservice.py.in
+@@ -1,4 +1,4 @@
+-#!/usr/bin/env python
++#!/usr/bin/env ${PY_STRING}
+ #
+ # Licensed to the Apache Software Foundation (ASF) under one
+ # or more contributor license agreements.  See the NOTICE file
+diff --git a/tools/qdmanage b/tools/qdmanage.in
+similarity index 99%
+rename from tools/qdmanage
+rename to tools/qdmanage.in
+index ffef1f1..9ed3adb 100755
+--- a/tools/qdmanage
++++ b/tools/qdmanage.in
+@@ -1,4 +1,4 @@
+-#!/usr/bin/env python
++#!/usr/bin/env ${PY_STRING}
+ 
+ #
+ # Licensed to the Apache Software Foundation (ASF) undeugr one
+diff --git a/tools/qdstat b/tools/qdstat.in
+similarity index 99%
+rename from tools/qdstat
+rename to tools/qdstat.in
+index 21ef985..d0ed533 100755
+--- a/tools/qdstat
++++ b/tools/qdstat.in
+@@ -1,4 +1,4 @@
+-#!/usr/bin/env python
++#!/usr/bin/env ${PY_STRING}
+ 
+ #
+ # Licensed to the Apache Software Foundation (ASF) under one
+-- 
+2.9.5
+
--- /dev/null
+++ qpid-dispatch-1.2.0/patches/series
@@ -0,0 +1 @@
+0001-DISPATCH-1087-Modified-shebang-line-in-some-files-to.patch
--- qpid-dispatch-1.2.0.orig/python/setup.py.in
+++ qpid-dispatch-1.2.0/python/setup.py.in
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env ${PY_STRING}
 #
 # Licensed to the Apache Software Foundation (ASF) under one
 # or more contributor license agreements.  See the NOTICE file
--- qpid-dispatch-1.2.0.orig/run.py.in
+++ qpid-dispatch-1.2.0/run.py.in
@@ -1,22 +1,22 @@
-#!/usr/bin/env python
-##
-## Licensed to the Apache Software Foundation (ASF) under one
-## or more contributor license agreements.  See the NOTICE file
-## distributed with this work for additional information
-## regarding copyright ownership.  The ASF licenses this file
-## to you under the Apache License, Version 2.0 (the
-## "License"); you may not use this file except in compliance
-## with the License.  You may obtain a copy of the License at
-##
-##   http://www.apache.org/licenses/LICENSE-2.0
-##
-## Unless required by applicable law or agreed to in writing,
-## software distributed under the License is distributed on an
-## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-## KIND, either express or implied.  See the License for the
-## specific language governing permissions and limitations
-## under the License
+#!/usr/bin/env ${PY_STRING}
 ##
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License
+#
 
 from __future__ import unicode_literals
 from __future__ import division
--- /dev/null
+++ qpid-dispatch-1.2.0/tests/authservice.py.in
@@ -0,0 +1,85 @@
+#!/usr/bin/env ${PY_STRING}
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+from __future__ import unicode_literals
+from __future__ import division
+from __future__ import absolute_import
+from __future__ import print_function
+
+import signal, optparse
+from proton.handlers import MessagingHandler
+from proton.reactor import Container
+from proton import Array, Data, symbol, UNDESCRIBED
+from cproton import pn_sasl_config_path
+
+class AuthService(MessagingHandler):
+    def __init__(self, address):
+        super(AuthService, self).__init__()
+        self.address = address
+        self.permissions = {}
+        self.allow('admin', '*', ['send', 'recv'])
+        self.allow('guest', 'foo', ['send', 'recv'])
+        self.listener = None
+
+    def allow(self, user, address, permissions):
+        if not self.permissions.get(user):
+            self.permissions[user] = {}
+        self.permissions[user][address] = Array(UNDESCRIBED, Data.STRING, *permissions)
+
+    def on_start(self, event):
+        self.listener = event.container.listen(self.address)
+
+    def stop(self):
+        if self.listener:
+            self.listener.close()
+
+    def on_connection_opening(self, event):
+        if self.permissions.get(event.transport.user):
+            event.connection.properties = {
+                symbol('authenticated-identity'): "%s" % event.transport.user,
+                symbol('address-authz'): self.permissions[event.transport.user]
+            }
+        else:
+            event.connection.properties = {
+                symbol('authenticated-identity'): "%s" % event.transport.user,
+                symbol('address-authz'): {}
+            }
+
+parser = optparse.OptionParser(usage="usage: %prog [options]",
+                               description="test authentication and authorization service")
+parser.add_option("-a", "--address", default="localhost:55671",
+                  help="address to listen on (default %default)")
+parser.add_option("-c", "--config", help="sasl config path")
+opts, args = parser.parse_args()
+
+print('starting')
+if opts.config:
+    pn_sasl_config_path(None, opts.config)
+    print('set sasl config path to %s' % opts.config)
+
+handler = AuthService(opts.address)
+def sigterm_handler(_signo, _stack_frame):
+    #sys.exit(0)
+    handler.stop()
+
+signal.signal(signal.SIGTERM, sigterm_handler)
+
+Container(handler).run()
+
--- /dev/null
+++ qpid-dispatch-1.2.0/tools/qdmanage.in
@@ -0,0 +1,242 @@
+#!/usr/bin/env ${PY_STRING}
+
+#
+# Licensed to the Apache Software Foundation (ASF) undeugr one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+from __future__ import unicode_literals
+from __future__ import division
+from __future__ import absolute_import
+from __future__ import print_function
+
+import sys, json, re
+import  qpid_dispatch_site
+from qpid_dispatch.management.client import Node, Url
+from collections import Mapping, Sequence
+from optparse import OptionGroup
+from qpid_dispatch_internal.tools.command import OptionParser, Option, UsageError, connection_options, check_args, \
+    main, opts_ssl_domain, opts_url, opts_sasl
+from qpid_dispatch_internal.management.qdrouter import QdSchema
+from qpid_dispatch_internal.compat import PY_TEXT_TYPE
+from qpid_dispatch_internal.compat import PY_STRING_TYPE
+
+INTEGER_TYPE = "integer"
+
+def attr_split(attrstr, qd_schema, type):
+    """Split an attribute string of the form name=value or name to indicate None"""
+    nv = attrstr.split("=", 1)
+    if len(nv) == 1:
+        return [nv[0], None]
+    else:
+        if nv[1] == "true":
+            nv[1] = True
+        elif nv[1] == "false":
+            nv[1] = False
+        elif type and qd_schema.entity_type(type) and qd_schema.entity_type(type).attribute(nv[0]).type == INTEGER_TYPE:
+            nv[1] = int(nv[1])
+
+        return nv
+
+
+class QdManage():
+    def __init__(self):
+        self.qd_schema = QdSchema()
+        self.prefix = 'org.apache.qpid.dispatch.'
+        self.operations = ['QUERY', 'CREATE', 'READ', 'UPDATE', 'DELETE',
+                           'GET-TYPES', 'GET-OPERATIONS', 'GET-ATTRIBUTES', 'GET-ANNOTATIONS',
+                           'GET-MGMT-NODES', 'GET-SCHEMA', 'GET-LOG']
+
+        usage = "%prog <operation> [options...] [arguments...]"
+        description = "Standard operations: %s. Use GET-OPERATIONS to find additional operations." \
+                      % (", ".join(self.operations))
+
+        op = OptionParser(usage=usage, option_class=Option, description=description)
+        op.add_option('--type', help='Type of entity to operate on.')
+        op.add_option('--name', help='Name of entity to operate on.')
+        op.add_option('--identity', help='Identity of entity to operate on.', metavar="ID")
+        op.add_option("--indent", type="int", default=2,
+                     help="Pretty-printing indent. -1 means don't pretty-print (default %default)")
+        op.add_option('--stdin', action='store_true',
+                      help='Read attributes as JSON map or list of maps from stdin.')
+        op.add_option('--body', help='JSON value to use as body of a non-standard operation call.')
+        op.add_option('--properties', help='JSON map to use as properties for a non-standard operation call.')
+        op.add_option_group(connection_options(op))
+        self.op = op
+
+    def clean_opts(self):
+        attr_type = self.opts.type
+        if attr_type:
+            self.opts.type = self.long_type(attr_type)
+
+    def run(self, argv):
+        # Make all args unicode to avoid encoding arg values as AMQP bytes.
+        al = [x.decode() if not isinstance(x, PY_TEXT_TYPE) else x
+              for x in argv[1:]]
+        self.opts, self.args = self.op.parse_args(al)
+        self.clean_opts()
+        if self.opts.indent == -1:
+            self.opts.indent = None
+        if len(self.args) == 0:
+            raise UsageError("No operation specified")
+        self.node = Node.connect(opts_url(self.opts), self.opts.router, self.opts.timeout,
+                                 opts_ssl_domain(self.opts),
+                                 opts_sasl(self.opts))
+
+        operation = self.args.pop(0)
+        method = operation.lower().replace('-','_')
+        if operation.upper() in self.operations and hasattr(self, method):
+            getattr(self, method)() # Built-in operation
+        else:
+            self.operation(operation) # Custom operation
+
+    def main(self, argv):
+        return main(self.run, argv, self.op)
+
+    def print_json(self, data):
+        """Print data as JSON"""
+        print("%s" % json.dumps(data, indent=self.opts.indent))
+
+    def print_result(self, result):
+        """Print a string result as-is, else try json dump, else print as-is"""
+        if not result: return
+        if isinstance(result, (PY_STRING_TYPE, PY_TEXT_TYPE)):
+            print("%s" % result)
+        else:
+            try:
+                self.print_json(result)
+            except ValueError:
+                print("%s" % result)
+
+    def long_type(self, type):
+        if not type or "." in type:
+            return type
+
+        if type in ('link', 'node'):
+            return self.prefix + "router." + type
+
+        if type in ('linkRoute', 'address', 'autoLink'):
+            return self.prefix + "router.config." + type
+
+        return self.prefix + type
+
+    def call_node(self, method, *argnames, **kwargs):
+        """Call method on node, use opts named in argnames"""
+        names = set(argnames)
+
+        attributes = kwargs.get('attributes')
+        if attributes and attributes.get('type'):
+            attributes['type'] = self.long_type(attributes['type'])
+
+        for k in self.opts.__dict__:
+            if k in names and hasattr(self.opts, k):
+                kwargs[k] = getattr(self.opts, k)
+
+        return getattr(self.node, method)(**kwargs)
+
+    def call_bulk(self, func):
+        """Call function for attributes from stdin or --attributes option"""
+        if self.opts.stdin:
+            data = json.load(sys.stdin)
+            if isinstance(data, Mapping):
+                self.print_json(func(data).attributes)
+            elif isinstance(data, Sequence):
+                self.print_json([func(attrs).attributes for attrs in data])
+            else: raise ValueError("stdin is not a JSON map or list")
+        else:
+            self.print_json(func(self.opts.attributes).attributes)
+
+    def query(self):
+        """query [ATTR...]          Print attributes of entities."""
+        if self.args:
+            self.opts.attribute_names = self.args
+        result = self.call_node('query', 'type', 'attribute_names')
+        self.print_json(result.get_dicts(clean=True))
+
+    def create(self):
+        """create [ATTR=VALUE...]   Create a new entity."""
+        if self.args:
+            self.opts.attributes = dict(attr_split(arg, self.qd_schema, self.opts.type) for arg in self.args)
+        self.call_bulk(lambda attrs: self.call_node('create', 'type', 'name', attributes=attrs))
+
+    def read(self):
+        """read                     Print attributes of selected entity."""
+        check_args(self.args, 0)
+        self.print_json(self.call_node('read', 'type', 'name', 'identity').attributes)
+
+    def update(self):
+        """update [ATTR=VALUE...]   Update an entity."""
+        if self.args:
+            self.opts.attributes = dict(attr_split(arg, self.qd_schema, self.opts.type) for arg in self.args)
+        self.call_bulk(
+            lambda attrs: self.call_node('update', 'type', 'name', 'identity', attributes=attrs))
+
+    def delete(self):
+        """delete                   Delete an entity"""
+        check_args(self.args, 0)
+        self.call_node('delete', 'type', 'name', 'identity')
+
+    def get_types(self):
+        """get-types [TYPE]         List entity types with their base types."""
+        if not self.opts.type:
+            self.opts.type = check_args(self.args, 1)[0]
+        self.print_json(self.call_node('get_types', 'type'))
+
+    def get_annotations(self):
+        """get-annotations [TYPE]   List entity types with the annotations they implement."""
+        if not self.opts.type:
+            self.opts.type = check_args(self.args, 1)[0]
+        self.print_json(self.call_node('get_annotations', 'type'))
+
+    def get_attributes(self):
+        """get-attributes [TYPE]    List entity types with their attributes."""
+        if not self.opts.type:
+            self.opts.type = check_args(self.args, 1)[0]
+        self.print_json(self.call_node('get_attributes', 'type'))
+
+    def get_operations(self):
+        """get-operations [TYPE]    List entity types with their operations."""
+        if not self.opts.type:
+            self.opts.type = check_args(self.args, 1)[0]
+        self.print_json(self.call_node('get_operations', 'type'))
+
+    def get_mgmt_nodes(self):
+        """get-mgmt-nodes           List of other known management nodes"""
+        check_args(self.args, 0)
+        self.print_json(self.call_node('get_mgmt_nodes'))
+
+    def json_arg(self, value):
+        try:
+            return json.loads(value)
+        except ValueError as e:
+            if not re.search(r'["{}\[\]]', value): # Doesn't look like attempted JSON.
+                return value    # Just treat as plain string
+            raise ValueError("Invalid JSON '%s': %s" % (value, e))
+
+    def operation(self, operation):
+        """operation [ATTR=VALUE...]   Call custom operation with ATTR=VALUE as request properties. Use --body and --properties if specified."""
+        properties = dict(attr_split(arg, self.qd_schema, self.opts.type) for arg in self.args or [])
+        if self.opts.properties:
+            properties.update(self.json_arg(self.opts.properties))
+        body = None
+        if self.opts.body:
+            body = self.json_arg(self.opts.body)
+        request = self.call_node('request', 'type', 'name', 'identity', operation=operation, body=body, **properties)
+        self.print_result(self.node.call(request).body)
+
+if __name__ == "__main__":
+    sys.exit(QdManage().main(sys.argv))
--- /dev/null
+++ qpid-dispatch-1.2.0/tools/qdstat.in
@@ -0,0 +1,574 @@
+#!/usr/bin/env ${PY_STRING}
+
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+from __future__ import unicode_literals
+from __future__ import division
+from __future__ import absolute_import
+from __future__ import print_function
+
+import os
+from optparse import OptionGroup
+import sys
+import locale
+import socket
+import re
+from time import ctime, strftime, gmtime
+import  qpid_dispatch_site
+from qpid_dispatch.management.client import Url, Node, Entity
+from qpid_dispatch_internal.management.qdrouter import QdSchema
+from qpid_dispatch_internal.tools import Display, Header, Sorter, YN, Commas, TimeLong
+from qpid_dispatch_internal.tools.command import connection_options, main, OptionParser, opts_ssl_domain, opts_sasl, \
+        opts_url
+from qpid_dispatch_internal.compat import UNICODE
+
+def parse_args(argv):
+    """ Set global variables for options, return arguments """
+
+    usage = "%prog [options]"
+
+    parser = OptionParser(usage=usage)
+
+    parser.add_option_group(connection_options(parser))
+
+    parser.add_option("-g", "--general", help="Show General Router Stats",  action="store_const", const="g",   dest="show")
+    parser.add_option("-c", "--connections", help="Show Connections",       action="store_const", const="c",   dest="show")
+    parser.add_option("-l", "--links", help="Show Router Links",            action="store_const", const="l",   dest="show")
+    parser.add_option("-n", "--nodes", help="Show Router Nodes",            action="store_const", const="n",   dest="show")
+    parser.add_option("-a", "--address", help="Show Router Addresses",      action="store_const", const="a",   dest="show")
+    parser.add_option("-m", "--memory", help="Show Router Memory Stats",    action="store_const", const="m",   dest="show")
+    parser.add_option("--autolinks", help="Show Auto Links",                action="store_const", const="autolinks",  dest="show")
+    parser.add_option("--linkroutes", help="Show Link Routes",              action="store_const", const="linkroutes", dest="show")
+    parser.add_option("-v", "--verbose", help="Show maximum detail",        action="store_true", dest="verbose")
+    parser.add_option("--log", help="Show recent log entries", action="store_const", const="log", dest="show")
+
+    # This limit can be used to limit the number of output rows and can be used in conjunction with options
+    # like -c, -l, -a, --autolinks, --linkroutes and --log.
+    # By default, the limit is set to 100 rows.
+    parser.add_option("--limit", help="Limit number of output rows", type="int", default=100)
+
+    opts, args = parser.parse_args(args=argv)
+
+    if not opts.show:
+        parser.error("You must specify one of these options: -g, -c, -l, -n, -a, -m, -h, --autolinks, --linkroutes, or --log.")
+
+    return opts, args
+
+
+def get(obj, attr):
+    if attr in obj.__dict__:
+        return obj.__dict__[attr]
+    return None
+
+
+class BusManager(Node):
+
+    schema = QdSchema()
+
+    def __init__(self, opts):
+        self.opts = opts
+        super(BusManager, self).__init__(
+            Node.connection(opts_url(opts), opts.router,
+                            timeout=opts.timeout,
+                            ssl_domain=opts_ssl_domain(opts),
+                            sasl=opts_sasl(self.opts)))
+
+    def query(self, entity_type, attribute_names=None, limit=None):
+        if attribute_names:
+            unames = []
+            for a in attribute_names:
+                unames.append(UNICODE(a))
+            attribute_names = unames
+        return super(BusManager, self).query(entity_type, attribute_names, count=limit).get_entities()
+
+    def connAuth(self, conn):
+        ##
+        ## Summarize the authentication for a connection:
+        ##   no-auth
+        ##   anonymous-user
+        ##   <user>(PLAIN)
+        ##   <user>(kerberos)
+        ##   <user>(x.509)
+        ##
+        if not conn.isAuthenticated:
+            return "no-auth"
+        sasl = conn.sasl
+        if sasl == "GSSAPI":
+            sasl = "Kerberos"
+        elif sasl == "EXTERNAL":
+            sasl = "x.509"
+        elif sasl == "ANONYMOUS":
+            return "anonymous-user"
+        if not conn.user:
+            return sasl
+        return "%s(%s)" % (conn.user, sasl)
+
+    def connSecurity(self, conn):
+        ##
+        ## Summarize the security of a connection:
+        ##   no-security
+        ##   SSLv3 (cipher)
+        ##   TLS (cipher)
+        ##   Kerberos
+        ##
+        if not conn.isEncrypted:
+            return "no-security"
+        if conn.sasl == "GSSAPI":
+            return "Kerberos"
+        return "%s(%s)" % (conn.sslProto, conn.sslCipher)
+
+    def noTrailingSlash(self, text):
+        if text == None:
+            return ""
+        if text[-1:] == '/':
+            return text[:-1]
+        return text
+
+    def displayConnections(self):
+        disp = Display(prefix="  ")
+        heads = []
+        heads.append(Header("id"))
+        heads.append(Header("host"))
+        heads.append(Header("container"))
+        heads.append(Header("role"))
+        heads.append(Header("dir"))
+        heads.append(Header("security"))
+        heads.append(Header("authentication"))
+        heads.append(Header("tenant"))
+
+        rows = []
+        objects = self.query('org.apache.qpid.dispatch.connection', limit=self.opts.limit)
+
+        for conn in objects:
+            row = []
+            row.append(conn.identity)
+            row.append(conn.host)
+            row.append(conn.container)
+            row.append(conn.role)
+            row.append(conn.dir)
+            row.append(self.connSecurity(conn))
+            row.append(self.connAuth(conn))
+            row.append(self.noTrailingSlash(get(conn, 'tenant')))
+            rows.append(row)
+        title = "Connections"
+        dispRows = rows
+        disp.formattedTable(title, heads, dispRows)
+
+    def _addr_summary(self, addr):
+        cls   = self._addr_class(addr)
+        phase = self._addr_phase(addr)
+        text  = self._addr_text(addr)
+        if cls == '-':
+            return "-"
+        if cls == 'M':
+            if phase == '0':
+                return text
+            else:
+                return "%s:%s" % (phase, text)
+        return "%s:%s" % (cls, text)
+
+
+    def _addr_class(self, addr):
+        if not addr:
+            return ""
+        if addr[0] == 'M' : return "mobile"
+        if addr[0] == 'R' : return "router"
+        if addr[0] == 'A' : return "area"
+        if addr[0] == 'L' : return "local"
+        if addr[0] == 'T' : return "topo"
+        if addr[0] in 'CE' : return "link-in"
+        if addr[0] in 'DF' : return "link-out"
+        return "unknown: %s" % addr[0]
+
+    def _addr_text(self, addr):
+        if not addr:
+            return ""
+        if addr[0] == 'M':
+            return addr[2:]
+        else:
+            return addr[1:]
+
+    def _addr_phase(self, addr):
+        if not addr:
+            return ""
+        if addr[0] == 'M':
+            return addr[1]
+        return ''
+
+    def _identity_clean(self, identity, router_id=None):
+        if router_id:
+            return router_id
+        if not identity:
+            return "-"
+        pos = identity.find('/')
+        if pos >= 0:
+            return identity[pos + 1:]
+        return identity
+
+    def _list_clean(self, inlist):
+        outlist = []
+        for i in inlist:
+            outlist.append(str(i))
+        return outlist
+
+    def displayGeneral(self):
+        disp = Display(prefix="  ")
+        heads = []
+        heads.append(Header("attr"))
+        heads.append(Header("value"))
+        rows = []
+
+        objects = self.query('org.apache.qpid.dispatch.router')
+
+        router = objects[0]
+        rows.append(('Version',       router.version))
+        rows.append(('Mode',          router.mode))
+        rows.append(('Router Id',     router.id))
+        rows.append(('Area',          router.area))
+        rows.append(('Link Routes',   router.linkRouteCount))
+        rows.append(('Auto Links',    router.autoLinkCount))
+        rows.append(('Links',         router.linkCount))
+        rows.append(('Nodes',         router.nodeCount))
+        rows.append(('Addresses',     router.addrCount))
+        rows.append(('Connections',   router.connectionCount))
+
+        # Overall delivery related counts.
+        # These overall statistics were introduced in 1.1 version.
+        # Wrap these in a try except so that newer versions of qdstat works with older version of router
+        try:
+            rows.append(('Presettled Count', router.presettledDeliveries))
+            rows.append(('Dropped Presettled Count', router.droppedPresettledDeliveries))
+            rows.append(('Accepted Count', router.acceptedDeliveries))
+            rows.append(('Rejected Count', router.rejectedDeliveries))
+            rows.append(('Released Count', router.releasedDeliveries))
+            rows.append(('Modified Count', router.modifiedDeliveries))
+            rows.append(('Ingress Count', router.deliveriesIngress))
+            rows.append(('Egress Count', router.deliveriesEgress))
+            rows.append(('Transit Count', router.deliveriesTransit))
+            rows.append(('Deliveries from Route Container', router.deliveriesIngressRouteContainer))
+            rows.append(('Deliveries to Route Container', router.deliveriesEgressRouteContainer))
+        except:
+            pass
+
+        title = "Router Statistics"
+        dispRows = rows
+        disp.formattedTable(title, heads, dispRows)
+
+    def displayRouterLinks(self):
+        disp = Display(prefix="  ")
+        heads = []
+        heads.append(Header("type"))
+        heads.append(Header("dir"))
+        heads.append(Header("conn id"))
+        heads.append(Header("id"))
+        heads.append(Header("peer"))
+        heads.append(Header("class"))
+        heads.append(Header("addr"))
+        heads.append(Header("phs"))
+        heads.append(Header("cap"))
+        heads.append(Header("undel"))
+        heads.append(Header("unsett"))
+        heads.append(Header("del"))
+        heads.append(Header("presett"))
+
+        rows = []
+        cols = ('linkType', 'linkDir', 'connectionId', 'identity', 'peer', 'owningAddr',
+                'capacity', 'undeliveredCount', 'unsettledCount', 'deliveryCount',
+                'presettledCount', 'droppedPresettledCount', 'acceptedCount', 'rejectedCount', 'releasedCount',
+                'modifiedCount', 'adminStatus', 'operStatus', 'linkName')
+
+        objects = self.query('org.apache.qpid.dispatch.router.link', cols, limit=self.opts.limit)
+
+        has_dropped_presettled_count = False
+
+        if objects:
+            first_row = objects[0]
+            if first_row:
+                if hasattr(first_row, 'droppedPresettledCount'):
+                    has_dropped_presettled_count = True
+
+        if has_dropped_presettled_count:
+            heads.append(Header("psdrop"))
+
+        heads.append(Header("acc"))
+        heads.append(Header("rej"))
+        heads.append(Header("rel"))
+        heads.append(Header("mod"))
+        heads.append(Header("admin"))
+        heads.append(Header("oper"))
+        if self.opts.verbose:
+            heads.append(Header("name"))
+
+        for link in objects:
+            row = []
+            row.append(link.linkType)
+            row.append(link.linkDir)
+            row.append(link.connectionId)
+            row.append(link.identity)
+            row.append(link.peer)
+            row.append(self._addr_class(link.owningAddr))
+            row.append(self._addr_text(link.owningAddr))
+            row.append(self._addr_phase(link.owningAddr))
+            row.append(link.capacity)
+            row.append(link.undeliveredCount)
+            row.append(link.unsettledCount)
+            row.append(link.deliveryCount)
+            row.append(link.presettledCount)
+            if has_dropped_presettled_count:
+                row.append(link.droppedPresettledCount)
+            row.append(link.acceptedCount)
+            row.append(link.rejectedCount)
+            row.append(link.releasedCount)
+            row.append(link.modifiedCount)
+            row.append(link.adminStatus)
+            row.append(link.operStatus)
+            if self.opts.verbose:
+                row.append(link.linkName)
+            rows.append(row)
+        title = "Router Links"
+        dispRows = rows
+        disp.formattedTable(title, heads, dispRows)
+
+    def displayRouterNodes(self):
+        disp = Display(prefix="  ")
+        heads = []
+        heads.append(Header("router-id"))
+        heads.append(Header("next-hop"))
+        heads.append(Header("link"))
+        if self.opts.verbose:
+            heads.append(Header("ver"))
+            heads.append(Header("cost"))
+            heads.append(Header("neighbors"))
+            heads.append(Header("valid-origins"))
+        rows = []
+        objects = self.query('org.apache.qpid.dispatch.router.node', limit=self.opts.limit)
+
+        # Find the most recent topo change in this neighborhood.
+        lastTopoChange = 0.0
+
+        for node in objects:
+            row = []
+            if node.lastTopoChange:
+                if float(node.lastTopoChange) > lastTopoChange:
+                    lastTopoChange = float(node.lastTopoChange)
+            row.append(node.id)
+            if node.nextHop != None:
+                row.append(node.nextHop)
+                row.append('-')
+            else:
+                row.append('-')
+                row.append(node.routerLink)
+
+            if self.opts.verbose:
+                row.append(get(node, 'protocolVersion'))
+                row.append(get(node, 'cost'))
+                row.append('%r' % self._list_clean(node.linkState))
+                row.append('%r' % self._list_clean(node.validOrigins))
+            rows.append(row)
+        if len(rows) > 0:
+            title = "Routers in the Network"
+            # Use gmtime to make times comparable across large networks.
+            if lastTopoChange > 1.0:
+                topoLine = "\nLast Topology Change: " + strftime('%A %b %d %H:%M:%S %Y',gmtime(lastTopoChange)) + " GMT"
+                title += topoLine
+            sort = Sorter(heads, rows, 'router-id')
+            dispRows = sort.getSorted()
+            disp.formattedTable(title, heads, dispRows)
+        else:
+            print("Router is Standalone - No Router List")
+
+    def displayAddresses(self):
+        disp = Display(prefix="  ")
+        heads = []
+        heads.append(Header("class"))
+        heads.append(Header("addr"))
+        heads.append(Header("phs"))
+        heads.append(Header("distrib"))
+        heads.append(Header("in-proc", Header.COMMAS))
+        heads.append(Header("local", Header.COMMAS))
+        heads.append(Header("remote", Header.COMMAS))
+        heads.append(Header("cntnr", Header.COMMAS))
+        heads.append(Header("in", Header.COMMAS))
+        heads.append(Header("out", Header.COMMAS))
+        heads.append(Header("thru", Header.COMMAS))
+        heads.append(Header("to-proc", Header.COMMAS))
+        heads.append(Header("from-proc", Header.COMMAS))
+        rows = []
+        cols = ('distribution', 'inProcess', 'subscriberCount', 'remoteCount',
+                'containerCount', 'deliveriesIngress', 'deliveriesEgress',
+                'deliveriesTransit', 'deliveriesToContainer', 'deliveriesFromContainer', 'name')
+
+        objects = self.query('org.apache.qpid.dispatch.router.address', cols, limit=self.opts.limit)
+
+        for addr in objects:
+            row = []
+            row.append(self._addr_class(addr.name))
+            row.append(self._addr_text(addr.name))
+            row.append(self._addr_phase(addr.name))
+            row.append(addr.distribution)
+            row.append(addr.inProcess)
+            row.append(addr.subscriberCount)
+            row.append(addr.remoteCount)
+            row.append(addr.containerCount)
+            row.append(addr.deliveriesIngress)
+            row.append(addr.deliveriesEgress)
+            row.append(addr.deliveriesTransit)
+            row.append(addr.deliveriesToContainer)
+            row.append(addr.deliveriesFromContainer)
+            rows.append(row)
+        title = "Router Addresses"
+        sorter = Sorter(heads, rows, 'addr', 0, True)
+        dispRows = sorter.getSorted()
+        disp.formattedTable(title, heads, dispRows)
+
+    def displayAutolinks(self):
+        disp = Display(prefix="  ")
+        heads = []
+        heads.append(Header("addr"))
+        heads.append(Header("dir"))
+        heads.append(Header("phs"))
+        heads.append(Header("extAddr"))
+        heads.append(Header("link"))
+        heads.append(Header("status"))
+        heads.append(Header("lastErr"))
+        rows = []
+        cols = ('addr', 'direction', 'phase', 'externalAddr', 'linkRef', 'operStatus', 'lastError')
+
+        objects = self.query('org.apache.qpid.dispatch.router.config.autoLink', cols, limit=self.opts.limit)
+
+        for al in objects:
+            row = []
+            row.append(al.addr)
+            row.append(al.direction)
+            row.append(al.phase)
+            row.append(al.externalAddr)
+            row.append(al.linkRef)
+            row.append(al.operStatus)
+            row.append(al.lastError)
+            rows.append(row)
+        title = "AutoLinks"
+        sorter = Sorter(heads, rows, 'addr', 0, True)
+        dispRows = sorter.getSorted()
+        disp.formattedTable(title, heads, dispRows)
+
+    def displayLinkRoutes(self):
+        disp = Display(prefix="  ")
+        heads = []
+        heads.append(Header("address"))
+        heads.append(Header("dir"))
+        heads.append(Header("distrib"))
+        heads.append(Header("status"))
+        rows = []
+        cols = ('prefix', 'direction', 'distribution', 'operStatus', 'pattern', 'addExternalPrefix', 'delExternalPrefix')
+
+        link_routes = self.query('org.apache.qpid.dispatch.router.config.linkRoute', cols, limit=self.opts.limit)
+
+        have_add_del_prefix = False
+        for link_route in link_routes:
+            row = []
+            row.append(link_route.prefix if link_route.prefix else link_route.pattern)
+            row.append(link_route.direction)
+            row.append(link_route.distribution)
+            row.append(link_route.operStatus)
+            try:
+                if link_route.addExternalPrefix or link_route.delExternalPrefix:
+                    row.append(link_route.addExternalPrefix)
+                    row.append(link_route.delExternalPrefix)
+                    have_add_del_prefix = True
+            except KeyError:
+                pass # added post 1.1.0
+            rows.append(row)
+        title = "Link Routes"
+        if have_add_del_prefix:
+            heads.append(Header("add-ext-prefix"))
+            heads.append(Header("del-ext-prefix"))
+        sorter = Sorter(heads, rows, 'address', 0, True)
+        dispRows = sorter.getSorted()
+        disp.formattedTable(title, heads, dispRows)
+
+    def displayMemory(self):
+        disp = Display(prefix="  ")
+        heads = []
+        heads.append(Header("type"))
+        heads.append(Header("size", Header.COMMAS))
+        heads.append(Header("batch"))
+        heads.append(Header("thread-max", Header.COMMAS))
+        heads.append(Header("total", Header.COMMAS))
+        heads.append(Header("in-threads", Header.COMMAS))
+        heads.append(Header("rebal-in", Header.COMMAS))
+        heads.append(Header("rebal-out", Header.COMMAS))
+        rows = []
+        cols = ('identity', 'typeSize', 'transferBatchSize', 'localFreeListMax',
+                'totalAllocFromHeap', 'heldByThreads', 'batchesRebalancedToThreads',
+                'batchesRebalancedToGlobal')
+
+        objects = self.query('org.apache.qpid.dispatch.allocator', cols)
+
+        for t in objects:
+            row = []
+            row.append(self._identity_clean(t.identity))
+            row.append(t.typeSize)
+            row.append(t.transferBatchSize)
+            row.append(t.localFreeListMax)
+            row.append(t.totalAllocFromHeap)
+            row.append(t.heldByThreads)
+            row.append(t.batchesRebalancedToThreads)
+            row.append(t.batchesRebalancedToGlobal)
+            rows.append(row)
+        if not rows:
+            # router built w/o memory pools:
+            print("No memory statistics available")
+            return
+        title = "Types"
+        sorter = Sorter(heads, rows, 'type', 0, True)
+        dispRows = sorter.getSorted()
+        disp.formattedTable(title, heads, dispRows)
+
+    def displayLog(self):
+        log = self.get_log(limit=self.opts.limit)
+        for line in log:
+            print("%s %s (%s) %s" % (ctime(line[5]), line[0], line[1], line[2]))
+
+    def displayMain(self, identitys, main):
+        if   main == 'l': self.displayRouterLinks()
+        elif main == 'n': self.displayRouterNodes()
+        elif main == 'a': self.displayAddresses()
+        elif main == 'm': self.displayMemory()
+        elif main == 'g': self.displayGeneral()
+        elif main == 'c': self.displayConnections()
+        elif main == 'autolinks': self.displayAutolinks()
+        elif main == 'linkroutes': self.displayLinkRoutes()
+        elif main == 'log': self.displayLog()
+
+    def display(self, identitys):
+        self.displayMain(identitys, self.opts.show)
+
+def run(argv):
+    opts, args = parse_args(argv)
+    if args[1:]:
+        raise Exception("Unexpected arguments: %s" % " ".join(args[1:]))
+    bm = BusManager(opts)
+    try:
+        bm.display(args)
+    finally:
+        bm.close()
+
+if __name__ == "__main__":
+        sys.exit(main(run, sys.argv))
